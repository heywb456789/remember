<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>토마토리멤버 - 영상통화</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Apple SD Gothic Neo', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }

    /* 메인 비디오 (전체 화면) */
    .main-video-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }

    .main-video {
      width: 100%;
      height: 100%;
      object-fit: contain; /* ✅ cover → contain으로 변경 */
      background: #000; /* ✅ 여백 부분 검은색 배경 */
      transition: opacity 0.5s ease;
    }

    /* 내 카메라 (우측 상단) - PC/모바일 반응형 */
    .my-camera-container {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 120px;
      height: 160px;
      background: #2c3e50;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      z-index: 100;
    }

    .my-camera {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .camera-placeholder {
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #3498db, #2980b9);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 24px;
    }

    /* 하단 컨트롤 바 - 고정 위치 보장 */
    .control-bar {
      position: fixed; /* ✅ absolute → fixed로 변경 */
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
      padding: 30px 20px 40px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      z-index: 1000; /* ✅ z-index 높임 */
      min-height: 120px; /* ✅ 최소 높이 보장 */
    }

    .control-btn {
      width: 60px;
      height: 60px;
      border-radius: 30px;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      flex-shrink: 0; /* ✅ 버튼 크기 유지 */
    }

    .record-btn {
      background: #e74c3c;
      box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
    }

    .record-btn:hover {
      background: #c0392b;
      transform: scale(1.1);
    }

    .record-btn.recording {
      background: #e74c3c;
      animation: recordingPulse 1.5s ease-in-out infinite;
    }

    .record-btn.recording::after {
      content: '';
      position: absolute;
      width: 80px;
      height: 80px;
      border: 2px solid rgba(231, 76, 60, 0.6);
      border-radius: 50%;
      animation: recordingRing 1.5s ease-out infinite;
    }

    @keyframes recordingPulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
    }

    @keyframes recordingRing {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      100% {
        transform: scale(1.3);
        opacity: 0;
      }
    }

    .end-call-btn {
      background: #e74c3c;
      box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
    }

    .end-call-btn:hover {
      background: #c0392b;
      transform: scale(1.1);
    }

    /* 상태 표시 */
    .status-indicator {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 16px;
      border-radius: 20px;
      color: white;
      font-size: 14px;
      backdrop-filter: blur(10px);
      z-index: 100;
      transition: opacity 0.3s ease;
    }

    .status-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      background: #27ae60;
      border-radius: 50%;
      margin-right: 8px;
      animation: statusBlink 2s ease-in-out infinite;
    }

    @keyframes statusBlink {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
    }

    /* 음소거 버튼 스타일 */
    .mute-btn {
      background: #95a5a6;
      box-shadow: 0 4px 15px rgba(149, 165, 166, 0.4);
    }

    .mute-btn:hover {
      background: #7f8c8d;
      transform: scale(1.1);
    }

    .mute-btn.active {
      background: #27ae60;
      box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
    }

    /* 음성 안내 말풍선 */
    .audio-guide {
      position: absolute;
      bottom: 130px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(52, 73, 94, 0.95);
      color: white;
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 14px;
      text-align: center;
      line-height: 1.4;
      backdrop-filter: blur(10px);
      z-index: 150;
      animation: guideBounce 0.5s ease-out;
      display: none;
    }

    .audio-guide.show {
      display: block;
    }

    .guide-arrow {
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid rgba(52, 73, 94, 0.95);
    }

    .guide-text strong {
      color: #f39c12;
    }

    @keyframes guideBounce {
      0% {
        transform: translateX(-50%) translateY(10px);
        opacity: 0;
      }
      100% {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }

    /* 펄스 효과 (버튼 강조) */
    .mute-btn.pulse {
      animation: mutePulse 1.5s ease-in-out infinite;
    }

    @keyframes mutePulse {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 4px 15px rgba(149, 165, 166, 0.4);
      }
      50% {
        transform: scale(1.05);
        box-shadow: 0 4px 20px rgba(241, 196, 15, 0.6);
      }
    }

    /* PC/태블릿 반응형 (768px 이상) */
    @media (min-width: 768px) {
      .my-camera-container {
        width: 180px; /* ✅ PC에서 카메라 크기 확대 */
        height: 240px;
        top: 30px;
        right: 30px;
      }

      .control-bar {
        padding: 40px 30px 50px;
        gap: 30px;
      }

      .control-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }

      .status-indicator {
        top: 30px;
        left: 30px;
        font-size: 16px;
        padding: 10px 20px;
      }

      .audio-guide {
        bottom: 160px;
        font-size: 16px;
        padding: 16px 20px;
      }

      /* ✅ PC에서 비디오 비율 조정 */
      .main-video {
        object-fit: contain; /* PC에서는 비율 유지 */
      }
    }

    /* 모바일 반응형 (480px 이하) */
    @media (max-width: 480px) {
      .my-camera-container {
        width: 100px;
        height: 133px;
        top: 15px;
        right: 15px;
      }

      .control-bar {
        padding: 20px 15px 30px; /* ✅ 모바일에서 패딩 조정 */
        gap: 15px;
        min-height: 100px; /* ✅ 모바일 최소 높이 */
      }

      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }

      .audio-guide {
        bottom: 120px;
        font-size: 13px;
        padding: 10px 14px;
      }

      .status-indicator {
        top: 15px;
        left: 15px;
        font-size: 12px;
        padding: 6px 12px;
      }

      /* ✅ 모바일에서는 cover 유지 (화면에 꽉 차게) */
      .main-video {
        object-fit: cover;
      }
    }

    /* 아이폰 SE 및 매우 작은 화면 (375px 이하) */
    @media (max-width: 375px) {
      .control-bar {
        padding: 15px 10px 25px; /* ✅ 매우 작은 화면 대응 */
        gap: 12px;
        min-height: 90px;
      }

      .control-btn {
        width: 45px;
        height: 45px;
        font-size: 18px;
      }

      .my-camera-container {
        width: 80px;
        height: 107px;
        top: 10px;
        right: 10px;
      }
    }

    /* 가로 모드 대응 */
    @media (orientation: landscape) and (max-height: 500px) {
      .control-bar {
        padding: 15px 20px 20px; /* ✅ 가로 모드에서 패딩 축소 */
        min-height: 80px;
      }

      .control-btn {
        width: 45px;
        height: 45px;
        font-size: 18px;
      }

      .my-camera-container {
        width: 80px;
        height: 107px;
        top: 10px;
        right: 10px;
      }

      .audio-guide {
        bottom: 90px;
      }
    }

    /* 끊김 없는 전환을 위한 추가 스타일 */
    @keyframes pulseGlow {
      0%, 100% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 0 20px rgba(52, 152, 219, 0.5);
      }
      50% {
        transform: translate(-50%, -50%) scale(1.05);
        box-shadow: 0 0 30px rgba(52, 152, 219, 0.8);
      }
    }

    @keyframes float {
      0%, 100% {
        transform: translateY(0px);
      }
      50% {
        transform: translateY(-10px);
      }
    }

    @keyframes fadeInOut {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      80% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
    }

    /* ✅ 안전 영역 대응 (아이폰 노치 등) */
    @supports (padding: max(0px)) {
      .control-bar {
        padding-bottom: max(30px, env(safe-area-inset-bottom));
      }

      .my-camera-container {
        top: max(20px, env(safe-area-inset-top));
        right: max(20px, env(safe-area-inset-right));
      }

      .status-indicator {
        top: max(20px, env(safe-area-inset-top));
        left: max(20px, env(safe-area-inset-left));
      }
    }
  </style>
</head>
<body>
<!-- 상태 표시 -->
<div class="status-indicator">
  <span class="status-dot"></span>
  <span id="statusText">연결 준비 중...</span>
</div>

<!-- 메인 비디오 (전체 화면) -->
<div class="main-video-container">
  <video id="mainVideo" class="main-video" autoplay loop muted playsinline>
    <source src="https://aicut.newstomato.com/remember/static/waiting_kt.mp4" type="video/mp4">
    대기 영상을 불러올 수 없습니다.
  </video>
</div>

<!-- 내 카메라 (우측 상단) -->
<div class="my-camera-container">
  <video id="myCamera" class="my-camera" autoplay muted playsinline style="display: none;"></video>
  <div id="cameraPlaceholder" class="camera-placeholder">📹</div>
</div>

<!-- 하단 컨트롤 -->
<div class="control-bar">
  <button id="recordBtn" class="control-btn record-btn" onclick="toggleRecording()">
    <span id="recordIcon">⏺</span>
  </button>

  <!-- 음소거 버튼 -->
  <button id="muteBtn" class="control-btn mute-btn" onclick="toggleMute()">
    <span id="muteIcon">🔇</span>
  </button>

  <button class="control-btn end-call-btn" onclick="endCall()">
    📞
  </button>
</div>

<!-- 음성 안내 말풍선 -->
<div id="audioGuide" class="audio-guide">
  <div class="guide-arrow"></div>
  <div class="guide-text">
    음성 재생을 위해<br>
    <strong>🔇 버튼을 터치</strong>해주세요
  </div>
</div>

<script>
    // ========== 전역 변수 ==========

    // 세션 및 연결 관련
    let sessionKey = null;
    let sseEventSource = null;

    // 녹화 관련
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;
    let userMediaStream = null;

    // 음소거 관련
    let isAudioEnabled = false;
    let guideTimeout = null;

    // 끊김 없는 영상 재생 관련
    let waitingVideoPreloaded = false;
    let currentVideoState = 'WAITING'; // WAITING, RESPONSE, TRANSITIONING
    let videoTransitionInProgress = false;

    // DOM 요소들
    const mainVideo = document.getElementById('mainVideo');
    const myCamera = document.getElementById('myCamera');
    const cameraPlaceholder = document.getElementById('cameraPlaceholder');
    const recordBtn = document.getElementById('recordBtn');
    const recordIcon = document.getElementById('recordIcon');
    const statusText = document.getElementById('statusText');
    const muteBtn = document.getElementById('muteBtn');
    const muteIcon = document.getElementById('muteIcon');
    const audioGuide = document.getElementById('audioGuide');

    // 전역 변수 추가
    let sseReconnectAttempts = 0;
    let maxReconnectAttempts = 10;
    let heartbeatInterval = null;
    let lastHeartbeat = Date.now();

    // ========== 1. 끊김 없는 영상통화 초기화 ==========
    async function initializeVideoCall() {
        try {
            console.log('🚀 영상통화 초기화 시작');

            // ✅ 1단계: 즉시 대기 영상 시작 (사용자는 바로 영상을 봄)
            await startWaitingVideoImmediately();

            // ✅ 2단계: 백그라운드에서 세션 생성 (비동기)
            initializeSessionInBackground();

            // ✅ 3단계: 백그라운드에서 카메라 권한 (비동기)
            initializeCameraInBackground();

            console.log('✅ 영상통화 초기화 완료 - 사용자는 즉시 영상을 보고 있음');

        } catch (error) {
            console.error('영상통화 초기화 오류:', error);
            handleInitializationError(error);
        }
    }

    // ========== 2. 즉시 대기 영상 시작 ==========
    async function startWaitingVideoImmediately() {
        try {
            const waitingVideoUrl = 'https://aicut.newstomato.com/remember/static/waiting_kt.mp4';

            // 비디오 엘리먼트 즉시 설정
            mainVideo.src = waitingVideoUrl;
            mainVideo.loop = true;
            mainVideo.muted = true;
            mainVideo.autoplay = true;

            // 비디오 이벤트 설정
            setupVideoEventListeners();

            // 즉시 재생 시도
            try {
                await mainVideo.play();
                console.log('✅ 대기 영상 즉시 재생 성공');
                currentVideoState = 'WAITING';
                waitingVideoPreloaded = true;

                updateStatusSmoothly('연결 준비 중...');

            } catch (playError) {
                if (playError.name === 'NotAllowedError') {
                    console.log('📱 자동재생 차단됨 - 사용자 터치 대기');
                    showTouchToPlayGuide();
                } else {
                    throw playError;
                }
            }

        } catch (error) {
            console.error('즉시 재생 실패:', error);
            showStaticBackground();
        }
    }

    // ========== 3. 백그라운드 세션 초기화 ==========
    async function initializeSessionInBackground() {
        try {
            const contactName = getCurrentContactName();
            console.log('🔄 백그라운드 세션 생성 중:', contactName);

            const sessionResponse = await fetch('/api/video/create-session', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({contactName: contactName})
            });

            const sessionData = await sessionResponse.json();

            if (sessionData.status.code === 'OK_0000') {
                sessionKey = sessionData.response.sessionKey;
                console.log('✅ 세션 생성 완료:', sessionKey);

                // SSE 연결 시작
                connectSSE();

                // 연결 모니터링 시작
                startConnectionMonitoring();

                // 네트워크 모니터링 설정
                setupNetworkMonitoring();

                updateStatusSmoothly('대기 중');

            } else {
                throw new Error(sessionData.status.message);
            }

        } catch (error) {
            console.error('백그라운드 세션 생성 실패:', error);
            updateStatusSmoothly('연결 재시도 중...');

            // 3초 후 재시도
            setTimeout(() => {
                initializeSessionInBackground();
            }, 3000);
        }
    }

    // ========== 4. 백그라운드 카메라 초기화 ==========
    async function initializeCameraInBackground() {
        try {
            console.log('🎥 백그라운드 카메라 초기화 중...');

            userMediaStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: {ideal: 1920, min: 1280},
                    height: {ideal: 1080, min: 720},
                    frameRate: {ideal: 30, min: 24},
                    facingMode: 'user'
                },
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    sampleRate: 44100
                }
            });

            myCamera.srcObject = userMediaStream;
            myCamera.style.display = 'block';
            cameraPlaceholder.style.display = 'none';

            console.log('✅ 카메라 초기화 완료');

        } catch (error) {
            console.error('카메라 초기화 실패:', error);
            showCameraError();
        }
    }

    // ========== 5. SSE 연결 ==========
    function connectSSE() {
        if (!sessionKey) {
            console.error('세션 키가 없습니다');
            return;
        }

        console.log(`🔗 SSE 연결 시도 (${sseReconnectAttempts + 1}/${maxReconnectAttempts}):`, sessionKey);

        // 기존 연결 정리
        if (sseEventSource) {
            sseEventSource.close();
            sseEventSource = null;
        }

        // 하트비트 정리
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
        }

        // 새 SSE 연결 생성
        sseEventSource = new EventSource(`/api/video/stream/${sessionKey}`);
        lastHeartbeat = Date.now();

        // ========== 연결 성공 이벤트 ==========
        sseEventSource.onopen = function (event) {
            console.log('✅ SSE 연결 성공');
            sseReconnectAttempts = 0; // 재연결 시도 횟수 리셋
            updateStatusSmoothly('연결 중...');

            // 하트비트 시작
            startHeartbeat();
        };

        // ========== 연결 완료 이벤트 ==========
        sseEventSource.addEventListener('connected', function (event) {
            try {
                const data = JSON.parse(event.data);
                console.log('📡 SSE 연결 완료:', data);
                updateStatusSmoothly(`${data.contactName}와 연결됨`);
                lastHeartbeat = Date.now();
            } catch (error) {
                console.error('Connected 이벤트 파싱 오류:', error);
                updateStatusSmoothly('연결됨');
            }
        });

        // ========== 하트비트 이벤트 ==========
        sseEventSource.addEventListener('heartbeat', function (event) {
            lastHeartbeat = Date.now();
            console.log('💓 하트비트 수신:', new Date().toLocaleTimeString());
        });

        // ========== 응답 영상 이벤트 ==========
        sseEventSource.addEventListener('response', function (event) {
            try {
                const data = JSON.parse(event.data);
                console.log('🎬 응답 영상 수신:', data);
                lastHeartbeat = Date.now();
                playResponseVideo(data.videoUrl);
            } catch (error) {
                console.error('Response 이벤트 파싱 오류:', error);
            }
        });

        // ========== 커스텀 오류 이벤트 ==========
        sseEventSource.addEventListener('error', function (event) {
            console.error('❌ SSE 커스텀 오류:', event);
            try {
                if (event.data) {
                    const data = JSON.parse(event.data);
                    console.error('오류 데이터:', data);
                    updateStatusSmoothly('처리 오류');
                    showErrorMessage(data.error || '서버 오류가 발생했습니다.');
                }
            } catch (parseError) {
                console.error('오류 이벤트 파싱 실패:', parseError);
            }
        });

        // ========== 연결 오류 처리 (핵심!) ==========
        sseEventSource.onerror = function (event) {
            console.error('🔥 SSE 연결 오류:', event);

            // 연결 상태별 처리
            switch (sseEventSource.readyState) {
                case EventSource.CONNECTING:
                    console.log('🔄 SSE 재연결 중...');
                    updateStatusSmoothly('재연결 중...');
                    return; // 브라우저가 자동 재연결 중이므로 대기

                case EventSource.CLOSED:
                    console.log('🚫 SSE 연결 닫힘');
                    updateStatusSmoothly('연결 종료');
                    handleSSEReconnection(); // 수동 재연결
                    return;

                default:
                    console.log('⚠️ SSE 연결 불안정');
                    updateStatusSmoothly('연결 불안정');
                    handleSSEReconnection(); // 수동 재연결
                    return;
            }
        };
    }

    // ========== 2. 하트비트 시스템 ==========
    function startHeartbeat() {
        // 기존 하트비트 정리
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
        }

        // 30초마다 하트비트 확인
        heartbeatInterval = setInterval(() => {
            const timeSinceLastHeartbeat = Date.now() - lastHeartbeat;
            const heartbeatTimeout = 60000; // 60초

            console.log(`💓 하트비트 체크: ${Math.round(timeSinceLastHeartbeat / 1000)}초 전`);

            // 하트비트 타임아웃 체크
            if (timeSinceLastHeartbeat > heartbeatTimeout) {
                console.warn('💔 하트비트 타임아웃 - 재연결 필요');
                handleSSEReconnection();
            }
        }, 30000); // 30초마다 체크
    }

    // ========== 3. 지능적인 재연결 로직 ==========
    function handleSSEReconnection() {
        // 하트비트 중지
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
        }

        // 재연결 시도 횟수 체크
        if (sseReconnectAttempts >= maxReconnectAttempts) {
            console.error('🚨 최대 재연결 시도 횟수 초과');
            updateStatusSmoothly('연결 실패');
            showErrorMessage('서버 연결에 실패했습니다. 페이지를 새로고침해주세요.');
            return;
        }

        sseReconnectAttempts++;

        // 지수 백오프 (1초, 2초, 4초, 8초, 16초, 최대 30초)
        const delay = Math.min(1000 * Math.pow(2, sseReconnectAttempts - 1), 30000);

        console.log(`🔄 ${delay / 1000}초 후 SSE 재연결 시도 (${sseReconnectAttempts}/${maxReconnectAttempts})`);
        updateStatusSmoothly(`${Math.round(delay / 1000)}초 후 재연결...`);

        setTimeout(() => {
            // 세션이 여전히 유효한지 확인
            if (sessionKey) {
                console.log('🔄 SSE 재연결 시작');
                connectSSE();
            } else {
                console.error('❌ 세션 키가 없어 재연결 불가');
            }
        }, delay);
    }

    // ========== 4. 연결 상태 모니터링 ==========
    function startConnectionMonitoring() {
        // 5분마다 연결 상태 확인
        setInterval(() => {
            if (!sseEventSource || sseEventSource.readyState !== EventSource.OPEN) {
                console.warn('⚠️ SSE 연결 상태 이상 - 재연결 시도');
                handleSSEReconnection();
            } else {
                console.log('✅ SSE 연결 상태 정상');
            }
        }, 300000); // 5분마다
    }

    // ========== 5. 네트워크 상태 감지 ==========
    function setupNetworkMonitoring() {
        let isOnline = navigator.onLine;

        window.addEventListener('online', () => {
            console.log('🌐 네트워크 연결됨');
            isOnline = true;
            updateStatusSmoothly('네트워크 복구됨');

            // 네트워크 복구 시 즉시 재연결
            setTimeout(() => {
                if (sessionKey && (!sseEventSource || sseEventSource.readyState !== EventSource.OPEN)) {
                    console.log('🔄 네트워크 복구 후 SSE 재연결');
                    sseReconnectAttempts = 0; // 재연결 시도 횟수 리셋
                    connectSSE();
                }
            }, 1000);
        });

        window.addEventListener('offline', () => {
            console.log('📵 네트워크 연결 끊김');
            isOnline = false;
            updateStatusSmoothly('네트워크 오프라인');

            // 오프라인 시 재연결 시도 중지
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        });
    }

    // ========== 6. 세션 유효성 확인 ==========
    async function validateSession() {
        if (!sessionKey) {
            return false;
        }

        try {
            const response = await fetch(`/api/video/session/${sessionKey}`, {
                method: 'GET',
                headers: {'Content-Type': 'application/json'}
            });

            const data = await response.json();

            if (data.status.code === 'OK_0000') {
                console.log('✅ 세션 유효성 확인 완료');
                return true;
            } else {
                console.error('❌ 세션이 유효하지 않음:', data.status.message);
                return false;
            }
        } catch (error) {
            console.error('❌ 세션 유효성 확인 실패:', error);
            return false;
        }
    }

    // ========== 6. 부드러운 상태 업데이트 ==========
    function updateStatusSmoothly(newStatus) {
        statusText.style.transition = 'opacity 0.3s ease';
        statusText.style.opacity = '0';

        setTimeout(() => {
            statusText.textContent = newStatus;
            statusText.style.opacity = '1';
        }, 150);
    }

    // ========== 7. 녹화 토글 ==========
    async function toggleRecording() {
        if (!isRecording) {
            await startRecording();
        } else {
            await stopRecording();
        }
    }

    // ========== 8. 녹화 시작 ==========
    async function startRecording() {
        if (!userMediaStream) {
            showErrorMessage('카메라가 연결되지 않았습니다.');
            return;
        }

        try {
            recordedChunks = [];

            const options = {
                mimeType: 'video/webm;codecs=vp9,opus',
                videoBitsPerSecond: 5000000,
                audioBitsPerSecond: 128000
            };

            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm;codecs=vp8,opus';
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm';
                }
            }

            mediaRecorder = new MediaRecorder(userMediaStream, options);

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                processRecordedVideo();
            };

            mediaRecorder.start();
            isRecording = true;

            recordBtn.classList.add('recording');
            recordIcon.textContent = '⏹';
            updateStatusSmoothly('녹화 중');

            console.log('📹 녹화 시작');

        } catch (error) {
            console.error('녹화 시작 오류:', error);
            showErrorMessage('녹화를 시작할 수 없습니다.');
        }
    }

    // ========== 9. 녹화 중지 ==========
    async function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;

            recordBtn.classList.remove('recording');
            recordIcon.textContent = '⏺';
            updateStatusSmoothly('처리 중');

            console.log('⏹ 녹화 중지');
        }
    }

    // ========== 10. 녹화 영상 처리 (로딩 없음) ==========
    async function processRecordedVideo() {
        if (!sessionKey) {
            showErrorMessage('세션이 유효하지 않습니다.');
            return;
        }

        try {
            console.log('📹 영상 처리 시작 - 로딩 화면 없음');

            // ✅ 로딩 오버레이 표시하지 않음 - 대기 영상 계속 재생
            updateStatusSmoothly('전송 중...');

            const blob = new Blob(recordedChunks, {type: 'video/webm'});
            const formData = new FormData();
            formData.append('video', blob, `recorded_video_${sessionKey}_${Date.now()}.webm`);

            console.log('📤 서버로 영상 전송 중...', sessionKey, blob.size, 'bytes');

            const response = await fetch(`/api/video/process/${sessionKey}`, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const result = await response.json();
                console.log('✅ 서버 응답:', result);

                updateStatusSmoothly('처리 중...');
                console.log('🔄 SSE 응답 대기 중...');
            } else {
                throw new Error('서버 응답 오류');
            }

        } catch (error) {
            console.error('영상 처리 오류:', error);
            updateStatusSmoothly('전송 실패');
            showErrorMessage('영상 처리 중 오류가 발생했습니다: ' + error.message);
        }
    }

    // ========== 11. 부드러운 응답 영상 전환 (핵심!) ==========
    async function playResponseVideo(videoUrl) {
        if (videoTransitionInProgress) {
            console.log('⏳ 영상 전환 중이므로 대기');
            return;
        }

        try {
            videoTransitionInProgress = true;
            console.log('🎬 응답 영상 재생 시작:', videoUrl);

            updateStatusSmoothly('응답 재생 중');
            currentVideoState = 'TRANSITIONING';

            // ✅ 새로운 비디오 엘리먼트로 프리로딩
            const responseVideo = document.createElement('video');
            responseVideo.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                object-fit: contain;
                background: #000;
                opacity: 0;
                transition: opacity 0.5s ease;
            `;

            responseVideo.src = videoUrl;
            responseVideo.loop = false;
            responseVideo.muted = !isAudioEnabled;
            if (isAudioEnabled) {
                responseVideo.volume = 0.8;
            }

            document.querySelector('.main-video-container').appendChild(responseVideo);

            // 프리로딩 완료 대기
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('응답 영상 로딩 타임아웃'));
                }, 10000);

                responseVideo.addEventListener('canplaythrough', () => {
                    clearTimeout(timeout);
                    resolve();
                }, {once: true});

                responseVideo.addEventListener('error', (e) => {
                    clearTimeout(timeout);
                    reject(e);
                }, {once: true});
            });

            // ✅ 부드러운 페이드 전환
            await responseVideo.play();
            responseVideo.style.opacity = '1';
            mainVideo.style.opacity = '0.3';

            currentVideoState = 'RESPONSE';

            if (!isAudioEnabled) {
                showAudioGuide();
            }

            // 응답 영상 종료 시 부드럽게 대기 영상으로 복귀
            responseVideo.addEventListener('ended', async () => {
                console.log('🔄 응답 영상 종료, 대기 영상으로 복귀');
                await returnToWaitingVideoSmoothly(responseVideo);
            }, {once: true});

        } catch (error) {
            console.error('응답 영상 재생 오류:', error);
            await handleResponseVideoError(error);
        } finally {
            videoTransitionInProgress = false;
        }
    }

    // ========== 12. 부드러운 대기 영상 복귀 ==========
    async function returnToWaitingVideoSmoothly(responseVideo) {
        try {
            console.log('🔄 대기 영상으로 부드럽게 복귀');

            currentVideoState = 'TRANSITIONING';

            mainVideo.style.transition = 'opacity 0.5s ease';
            mainVideo.style.opacity = '1';
            responseVideo.style.opacity = '0';

            setTimeout(() => {
                if (responseVideo.parentNode) {
                    responseVideo.parentNode.removeChild(responseVideo);
                }

                currentVideoState = 'WAITING';
                updateStatusSmoothly('대기 중');
                console.log('✅ 대기 영상으로 복귀 완료');
            }, 500);

        } catch (error) {
            console.error('대기 영상 복귀 오류:', error);
            if (responseVideo.parentNode) {
                responseVideo.parentNode.removeChild(responseVideo);
            }
            currentVideoState = 'WAITING';
            mainVideo.style.opacity = '1';
        }
    }

    // ========== 13. 음소거 토글 ==========
    async function toggleMute() {
        try {
            if (!isAudioEnabled) {
                await enableAudio();
            } else {
                disableAudio();
            }
        } catch (error) {
            console.error('음소거 토글 오류:', error);
            showErrorMessage('음성 설정에 실패했습니다.');
        }
    }

    // ========== 14. 오디오 활성화 ==========
    async function enableAudio() {
        try {
            mainVideo.muted = false;
            mainVideo.volume = 0.01;
            await mainVideo.play();

            isAudioEnabled = true;
            mainVideo.muted = true;
            mainVideo.volume = 0.8;

            muteIcon.textContent = '🔊';
            muteBtn.classList.add('active');

            hideAudioGuide();
            showSuccessMessage('음성이 활성화되었습니다!');
            console.log('🔊 오디오 활성화 완료');

        } catch (error) {
            console.error('오디오 활성화 실패:', error);
            showErrorMessage('음성 활성화에 실패했습니다.');
        }
    }

    // ========== 15. 오디오 비활성화 ==========
    function disableAudio() {
        isAudioEnabled = false;
        mainVideo.muted = true;
        muteIcon.textContent = '🔇';
        muteBtn.classList.remove('active');
        console.log('🔇 오디오 비활성화 완료');
    }

    // ========== 16. 음성 안내 표시/숨김 ==========
    function showAudioGuide() {
        if (!isAudioEnabled) {
            audioGuide.classList.add('show');
            muteBtn.classList.add('pulse');

            guideTimeout = setTimeout(() => {
                hideAudioGuide();
            }, 5000);
        }
    }

    function hideAudioGuide() {
        audioGuide.classList.remove('show');
        muteBtn.classList.remove('pulse');

        if (guideTimeout) {
            clearTimeout(guideTimeout);
            guideTimeout = null;
        }
    }

    // ========== 17. 터치로 재생 가이드 ==========
    function showTouchToPlayGuide() {
        const guide = document.createElement('div');
        guide.id = 'touchGuide';
        guide.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 24px;
            border-radius: 16px;
            text-align: center;
            z-index: 200;
            font-size: 16px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            animation: pulseGlow 2s ease-in-out infinite;
        `;
        guide.innerHTML = `
            <div style="font-size: 48px; margin-bottom: 16px;">🎬</div>
            <div style="font-weight: 600; margin-bottom: 8px;">화면을 터치해주세요</div>
            <div style="font-size: 14px; opacity: 0.8;">영상을 시작하려면 터치가 필요합니다</div>
        `;

        guide.onclick = async () => {
            try {
                await mainVideo.play();
                guide.remove();
                console.log('✅ 사용자 터치로 재생 시작');
                updateStatusSmoothly('연결 준비 중...');
            } catch (e) {
                console.error('수동 재생 실패:', e);
            }
        };

        document.querySelector('.main-video-container').appendChild(guide);
    }

    // ========== 18. 비디오 이벤트 리스너 설정 ==========
    function setupVideoEventListeners() {
        mainVideo.addEventListener('error', (e) => {
            console.error('대기 영상 오류:', e);
            if (currentVideoState === 'WAITING') {
                showStaticBackground();
            }
        });

        mainVideo.addEventListener('stalled', () => {
            console.warn('대기 영상 로딩 지연');
        });

        mainVideo.addEventListener('waiting', () => {
            console.log('대기 영상 버퍼링 중...');
        });

        mainVideo.addEventListener('canplay', () => {
            console.log('대기 영상 재생 준비 완료');
        });
    }

    // ========== 19. 대체 배경 표시 ==========
    function showStaticBackground() {
        console.log('📺 대체 배경 표시');
        mainVideo.style.display = 'none';
        const container = document.querySelector('.main-video-container');

        container.style.background = 'linear-gradient(135deg, #2c3e50, #34495e)';

        const fallback = document.createElement('div');
        fallback.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-size: 18px;
        `;
        fallback.innerHTML = `
            <div style="font-size: 64px; margin-bottom: 20px; animation: float 3s ease-in-out infinite;">📹</div>
            <div style="font-weight: 600;">연결을 준비하고 있습니다</div>
            <div style="font-size: 14px; opacity: 0.7; margin-top: 8px;">잠시만 기다려주세요</div>
        `;

        container.appendChild(fallback);
    }

    // ========== 20. 오류 처리 ==========
    function handleInitializationError(error) {
        console.error('초기화 실패:', error);
        showStaticBackground();
        updateStatusSmoothly('연결 재시도 중...');

        setTimeout(() => {
            window.location.reload();
        }, 5000);
    }

    async function handleResponseVideoError(error) {
        console.error('응답 영상 오류:', error);

        if (error.name === 'NotAllowedError') {
            showAudioGuide();
        }

        currentVideoState = 'WAITING';
        mainVideo.style.opacity = '1';
        updateStatusSmoothly('대기 중');
    }

    function showCameraError() {
        console.log('📷 카메라 오류 - 플레이스홀더 유지');
        // 카메라 실패해도 영상통화는 계속 진행
    }

    // ========== 21. 유틸리티 함수들 ==========
    function getCurrentContactName() {
        const urlParams = new URLSearchParams(window.location.search);
        const contactName = urlParams.get('contact') ||
            localStorage.getItem('selectedContact') ||
            '김근태';
        return contactName;
    }

    function showSuccessMessage(message) {
        const successDiv = document.createElement('div');
        successDiv.textContent = message;
        successDiv.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(39, 174, 96, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
        `;

        document.body.appendChild(successDiv);
        setTimeout(() => successDiv.remove(), 2000);
    }

    function showErrorMessage(message) {
        const errorDiv = document.createElement('div');
        errorDiv.textContent = message;
        errorDiv.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(231, 76, 60, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
        `;

        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 2000);
    }

    // ========== 22. 통화 종료 ==========
    function endCall() {
        if (confirm('영상통화를 종료하시겠습니까?')) {
            enhancedCleanup();

            if (isRecording && mediaRecorder) {
                try {
                    mediaRecorder.stop();
                    isRecording = false;
                } catch (error) {
                    console.error('녹화 중지 오류:', error);
                }
            }

            sessionKey = null;
            // ✅ 온보딩 상태에 따른 리다이렉트
            const hasOnboarding = hasCompletedOnboarding();
            const redirectPath = hasOnboarding ? '/mobile/home' : '/mobile/onboarding';

            console.log('🔄 페이지 리다이렉트:', {
                hasCompletedOnboarding: hasOnboarding,
                redirectPath: redirectPath
            });

            window.location.href = redirectPath;
        }
    }

    function hasCompletedOnboarding() {
        try {
            const onboardingData = localStorage.getItem('onboarding_completed');
            if (!onboardingData) return false;

            const data = JSON.parse(onboardingData);
            return data.completed === true;
        } catch (error) {
            console.error('온보딩 상태 확인 오류:', error);
            return false;
        }
    }

    // ========== 23. 리소스 정리 ==========
    function enhancedCleanup() {
        console.log('🧹 강화된 리소스 정리 시작');

        // 하트비트 정리
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
        }

        // SSE 연결 정리
        if (sseEventSource) {
            sseEventSource.close();
            sseEventSource = null;
        }

        // ✅ 세션 관련 로컬스토리지 정리
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && (key.startsWith('sessionKey') || key.startsWith('VC_'))) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
        console.log('🗑️ 정리된 세션 키들:', keysToRemove);

        // ✅ 현재 세션 초기화
        sessionKey = null;
        sseReconnectAttempts = 0;

        // 기타 정리
        if (guideTimeout) {
            clearTimeout(guideTimeout);
            guideTimeout = null;
        }

        if (userMediaStream) {
            userMediaStream.getTracks().forEach(track => {
                track.stop();
                console.log('미디어 트랙 정리:', track.kind);
            });
            userMediaStream = null;
        }

        recordedChunks = [];

        console.log('✅ 강화된 리소스 정리 완료');
    }

    function detectAndCleanOldSessions() {
        const currentTime = Date.now();
        const sessionTimeout = 10 * 60 * 1000; // 10분

        // 마지막 활동 시간 체크
        const lastActivity = localStorage.getItem('lastVideoCallActivity');
        if (lastActivity) {
            const timeDiff = currentTime - parseInt(lastActivity);
            if (timeDiff > sessionTimeout) {
                console.log('⚠️ 오래된 세션 감지 - 정리 중');
                enhancedCleanup();
            }
        }

        // 현재 시간 저장
        localStorage.setItem('lastVideoCallActivity', currentTime.toString());
    }

    // ========== 24. 이벤트 리스너 설정 ==========
    // ✅ 초기화 시 오래된 세션 정리
    window.addEventListener('load', function () {
        console.log('🌐 페이지 로드 완료');
        setTimeout(() => {
            if (!sessionKey) {
                console.log('🔄 백업 초기화 실행');
                initializeVideoCall();
            }
        }, 500);
    });

    window.addEventListener('beforeunload', () => {
        enhancedCleanup();

        // ✅ 서버에 세션 종료 알림 (Best Effort)
        if (sessionKey) {
            navigator.sendBeacon(`/api/video/session/${sessionKey}/cleanup`);
        }
    });

    window.addEventListener('pageshow', (event) => {
        if (event.persisted) {
            console.log('🔄 페이지 캐시에서 복원됨 - 전체 새로고침 필요');
            window.location.reload();
        }
    });

    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            console.log('페이지가 숨겨짐 (앱 전환)');
        } else {
            console.log('페이지가 표시됨 (앱 복귀)');
            if (sessionKey && (!sseEventSource || sseEventSource.readyState !== EventSource.OPEN)) {
                setTimeout(() => {
                    console.log('앱 복귀 후 SSE 재연결');
                    connectSSE();
                }, 500);
            }
        }
    });

    // 터치 이벤트 최적화 (모바일)
    if ('ontouchstart' in window) {
        document.addEventListener('touchstart', function () {
        }, {passive: true});

        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    }

    // ========== 자동 실행 코드 추가 ==========
    document.addEventListener('DOMContentLoaded', function () {
        console.log('📄 DOM 로드 완료 - 영상통화 초기화 시작');
        initializeVideoCall();
    });

    console.log('🎬 끊김 없는 영상통화 시스템 로드 완료');
</script>
</body>
</html>